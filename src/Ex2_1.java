import java.io.*;
import java.util.Random;
import java.util.concurrent.*;
import java.util.List;
import java.util.ArrayList;


public class Ex2_1 {
    /**
     * Creates a specified number of text files with random content.
     *
     * @param n     the number of files to create
     * @param seed  the seed for the random number generator
     * @param bound the upper bound for the random numbers generated by the random number generator
     * @return an array of strings containing the names of the created files
     * @throws FileNotFoundException        if the file cannot be created
     * @throws UnsupportedEncodingException if the encoding is not supported
     */
    public static String[] createTextFiles(int n, int seed, int bound) throws FileNotFoundException, UnsupportedEncodingException {
        String[] fileArr = new String[n];
        String namingFiles = "file_";
        Random rand = new Random(seed);
        for (int i = 0; i < n; i++) {
            String namingFilesWithNum = namingFiles + i;
            File file = new File(namingFilesWithNum + ".txt");
            PrintWriter writer = new PrintWriter(file);
            int x = rand.nextInt(bound);
            String writerInput = ("Yovel and Noam Assignment_2_OOP \r\n");
            for (int j = 0; j < x; j++) {
                writerInput = writerInput + writerInput;
            }
            writer.println(writerInput);
            writer.close();
            fileArr[i] = namingFilesWithNum + ".txt";
        }
        return fileArr;
    }

    /**
     * Returns the number of lines in the specified array of files.
     *
     * @param fileNames an array of file names
     * @return the number of lines in the files
     */
    public static int getNumOfLines(String[] fileNames) {
        int numOfLines = 0;
        for (int i = 0; i < fileNames.length; i++) {
            try {
                BufferedReader reader = new BufferedReader(new FileReader(fileNames[i]));
                while (reader.readLine() != null) {
                    numOfLines++;
                }
                reader.close();
            } catch (Exception e) {
                e.getStackTrace();
            }
        }
        return numOfLines - fileNames.length;
    }


    /**
     * A thread that counts the number of lines in a file.
     */
    public static class fileThread extends Thread {
        private String fileName;
        private int lineCountCons;

        public fileThread(String fileName) {
            this.fileName = fileName;
            this.lineCountCons = 0;
        }

        @Override
        public void run() {
            int lineCount = 0;
            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
                while (reader.readLine() != null) {
                    lineCount++;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            this.lineCountCons = lineCount;
        }

        public int getLineCount() {
            return lineCountCons;
        }
    }

    /**
     * Returns the number of lines in the specified array of files using separate threads for each file.
     *
     * @param fileNames an array of file names
     * @return the number of lines in the files
     */
    public static int getNumOfLinesThreads(String[] fileNames)  {
        int count = fileNames.length, i = 0, numOfLines = 0;
        while (i < count) {
            fileThread file = new fileThread(fileNames[i]);
            file.start();
            try {
                file.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            numOfLines = numOfLines + file.getLineCount();
            i++;
        }
        return numOfLines - fileNames.length;
    }
    /**
     * A Callable task that counts the number of lines in a file.
     */
    public static class callCountLines implements Callable<Integer> {
        private String fileName;

        public callCountLines(String fileName) {
            this.fileName = fileName;
        }

        @Override
        public Integer call() throws Exception {
            int lineCount = 0;
            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
                while (reader.readLine() != null) {
                    lineCount++;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            return lineCount;
        }
    }

    /**
     * Returns the number of lines in the specified array of files using a thread pool.
     *
     * @param fileNames an array of file names
     * @return the number of lines in the files
     * @throws ExecutionException   if the task throws an exception
     * @throws InterruptedException if the current thread was interrupted while waiting
     */
    public static int getNumOfLinesThreadPool(String[] fileNames) throws ExecutionException, InterruptedException {
     int poolSize= fileNames.length;
        ExecutorService executor = Executors.newFixedThreadPool(poolSize);
        List<Future<Integer>> futures = new ArrayList<>();
        for (String fileName : fileNames) {
            Callable<Integer> task = new callCountLines(fileName);
            Future<Integer> future = executor.submit(task);
            futures.add(future);
        }
        int sumOfLines = 0;
        for (Future<Integer> future : futures) {
            sumOfLines += future.get();
        }
        executor.shutdownNow();
        return sumOfLines - fileNames.length;
    }

    public static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException, ExecutionException, InterruptedException {
        String[] fileNames = Ex2_1.createTextFiles(100, 4, 10);

        // Measure the execution time of the getNumOfLines() method
        long startTime = System.currentTimeMillis();
        int numOfLines = Ex2_1.getNumOfLines(fileNames);
        long endTime = System.currentTimeMillis();
        long elapsedTime = endTime - startTime;
        System.out.println("Elapsed time for getNumOfLines(): " + elapsedTime + " milliseconds");

        // Measure the execution time of the getNumOfLinesThreads() method
        startTime = System.currentTimeMillis();
        int numOfLinesThreads = Ex2_1.getNumOfLinesThreads(fileNames);
        endTime = System.currentTimeMillis();
        elapsedTime = endTime - startTime;
        System.out.println("Elapsed time for getNumOfLinesThreads(): " + elapsedTime + " milliseconds");

        // Measure the execution time of the getNumOfLinesThreadPool() method
        startTime = System.currentTimeMillis();
        int numOfLinesThreadPool = Ex2_1.getNumOfLinesThreadPool(fileNames);
        endTime = System.currentTimeMillis();
        elapsedTime = endTime - startTime;
        System.out.println("Elapsed time for getNumOfLinesThreadPool(): " + elapsedTime + " milliseconds");
    }
}


